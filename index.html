<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <!--
    Copyright 2021 Sharyndor
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
  -->
  <title>Brookview</title>
  <style type='text/css'>
    /* Prefer not to burn out people's eyes */
    :root {
      background-color: #202020;
    }
    
    /* Borderless */
    * {
      margin:  0;
      padding: 0;
    }
    
    /* Remove the scrollbar */
    body {
      overflow: hidden;
    }
    
    /* Tightly packed grid, rows/columns set via scripts */
    #grid {
      display: inline-grid;
      grid-auto-rows: 1fr;
      grid-gap: 0px;
    }
    
    /* Hide by default, float it near the side */
    .overlay {
      position: absolute;
      padding-left: 5px;
      padding-right: 5px;
      width:auto;
      height:auto;
      z-index: 325;
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      background-color: #585858;
      border-style: solid;
      border-color: #A0A0A0;
      border-radius: 5px;
      color: #BEBEBE;
    }
    
    .overlayListElement[status="live"] {
      color: green;
    }
    
    .overlayListElement[status="upcoming"] {
      color: yellow;
    }
    
    .overlayListElement[status="offline"] {
      display: none;
      color: red;
    }
    
    form {
      overflow: hidden;
      align-items: center;
    }
    
    label {
      padding-right: 40px;
    }
    
    input {
      float: right;
      clear: both;
    }
    
    /* Show overlay items as clickable */
    summary, details > div {
      cursor: pointer;
      width: fit-content;
    }
    
    /* Indent the channel names */
    details > div {
      padding-left: 20px;
    }

    /* Indent each depth of details */
    details > details {
      padding-left: 20px;
    }

    .grid-element {
      position: relative;
    }

    .grid-element > * {
      position: absolute;
      width: 100%;
      height: 100%;
      border: none;

      z-index: 200;
    }

    .grid-element :last-child {
      z-index: 100;
    }

    .grid-overlay {
      opacity: 80%;
      user-select: none;
    }
    
    /* Make it obvious what you have selected */
    .grid-overlay:hover {
      box-sizing: border-box;
      border: #585858 solid 3px;
    }

    .grid-overlay.fade {
      opacity: 0%;
      transition: opacity 2s linear 0.5s;
    }
    
    /* Center the hover text */
    .grid-overlay :first-child {
      display: none;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      
      font-family: Arial;
      font-size: 4vw;
      color: #BEBEBE;
      -webkit-text-stroke-width: 1px;
      -webkit-text-stroke-color: black;
    }
    
    /* Don't allow the hover text to be selectable */
    .grid-overlay:hover :first-child {
      display: inline;
      user-select: none;
    }
    
    /* Block iframe interaction when disabled */
    .grid-overlay.disabled {
      pointer-events: none;
      display: none;
    }
    
    /* Simple pop-up text for next/prev */
    .grid-status {
      display: none;
      user-select: none;
      position: absolute;
      left: 50%;
      top: 30%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      
      font-family: Arial;
      font-size: 3vw;

      opacity: 80%;
      
      color:#FFFFFF;
      -webkit-text-stroke-width: 2px;
      -webkit-text-stroke-color: black;
    }
    
    /* Only show on hover */
    .grid-element:hover :nth-child(2) {
      display: inline
    }
    
    #chat {
      float: right;
      
      color: #BEBEBE;
      background-color: #202020;
    }

    #chat > select > option[type="blank"] {
      display: none;
    }

    #chat > select > option[type="yt-channel"] {
      display: none;
    }

    #chat > select > option[type="ttv-video"] {
      display: none;
    }

    #overlayInput {
      display: none;
      position: absolute;
      transform: translate(-50%, 0%);
      z-index: 350;
      background-color: #585858;
      border-style: solid;
      border-color: #A0A0A0;
      border-radius: 5px;

      width: 20%;
    }

    #inputText {
      position: relative;
      color: black;
      width: 100%;
    }

    #overlayInput > div {
      color: white;
    }

    #inputList {
      overflow-y: auto;
      line-height: 2.5ex;
      max-height: 25ex;
      width: 100%;
    }

    #overlayBlur {
      display: none;
      position: fixed;
      height: 100vh;
      width: 100vw;
      pointer-events: none;
      opacity: 30%;
      z-index: 325;
    }
    
    /* width */
    ::-webkit-scrollbar {
      width: 10px;
    }

    /* Track */
    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    /* Handle */
    ::-webkit-scrollbar-thumb {
      background: #888;
    }

    /* Handle on hover */
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

  </style>
</head>

<body>
  <div id=overlayInput class=overlay>
    <input id=inputText type=text autocomplete=off placeholder="Enter a streamer name, channel link, or video link"><div></div></input>
    <div id=inputList></div>
  </div>
  <div id=overlayBlur class="overlay"></div>
  <div id=overlayHelp class=overlay style="display: none"></div>
  <div id=overlayList class=overlay style="display: none"></div>
  <div id=overlaySettings class=overlay style="display: none"></div>
  <div id=overlayMod class=overlay style="display: none"></div>
  <div id=grid></div>
  <div id=chat style="display: none">
    <label>Chat:</label>
    <select>
      <option>None</option>
    </select>
    <div></div>
  </div>
  
  <script>
    var hostDomain = 'sharyndor.github.io'

    var backendRepo = 'https://github.com/sharyndor/brookview-backend'
    var supportedBackendVersion = [0, 4, 0] /* vMajor.Minor.Patch */
    
    function getReserved(str) {
      /* These words are reserved for internal use */
      return ['rows', 'columns', 'backend', 'blank']
    }
    
    function getReferFunctions() {
      return [
        referAlias,
        referYoutube,
        referTwitch,
      ]
    }
    function getEmbeds() {
      return { 
        'blank'       : null,
        'alias'       : embedAlias,
        'yt-video'    : embedYoutubeVideo,
        'yt-channel'  : embedYoutubeChannel,
        'ttv-video'   : embedTwitchVideo,
        'ttv-channel' : embedTwitchChannel,
      }
    }

    function referAlias(alias) {
      alias = alias.toLowerCase()
      if (alias in global.aliases) {
        return ['alias', alias, []]
      }
      return null
    }
    
    function referYoutube(str) {
      /* Try to treat the string as a URL */
      try {
        /* Parse the string to find the type of content */
        var url = new URL(str)
        if (url.host.includes('youtube')) {
          if (url.searchParams.has('v')) { /* Normal video link, parse out the video id and timestamp (if present) */
            var timeStamp = url.searchParams.get('t')
            var extras = timeStamp ? '&start=' + timeStamp : ''
            return ['yt-video', url.searchParams.get('v'), extras]
          } else if (url.pathname.includes('/c/')) { /* Custom channel link cannot be used, actual channel id is needed instead */
            return checkReferers(prompt('Embed needs URL with channel ID'))
          } else if (url.pathname.includes('/channel/')) { /* Normal channel link, parse out the channel id */
            return ['yt-channel', url.pathname.split('/channel/')[1]]
          }
        } else if (url.host.includes('youtu.be')) { /* Short video link, parse out the video id and timestamp (if present) */
          var timestamp = url.searchParams.get('t')
          var extras = timestamp ? '&start=' + timestamp : ''
          return ['yt-video', url.pathname.substring(1), extras]
        }
        return null
      }
      /* Wasn't a URL */
      catch (error) {
        return null
      }
    }
    
    function referTwitch(str) {
      /* Start with ttv- as shorthand for twitch channels */
      if (str.startsWith('ttv-')) {
        return ['ttv-channel', str.substring(4)]
      }
      else {
        /* Try to treat the string as a URL */
        try {
          /* Parse the string to find the type of content */
          var url = new URL(str)
          if (url.host.includes('twitch.tv')) {
            if (url.pathname.includes('/videos/')) { /* VOD */
              var timeStamp = url.searchParams.get('t')
              var extras = timeStamp ? '&time=' + timeStamp : ''
              return ['ttv-video', url.pathname.split('/videos/')[1], extras]
            } else { /* Probably trying to reference a channel, parse out the channel name */
              return ['ttv-channel', url.pathname.split('/')[1].split('/')[0]]
            }
          }
          return null
        }
        /* Wasn't a URL */
        catch (error) {
          return null
        }
      }
    }
    
    
    function embedYoutubeVideo(value, extras) {
      return 'https://www.youtube.com/embed/' + value + '?autoplay=1&mute=1' + extras
    }
    
    function embedYoutubeChannel(value) {
      return 'https://www.youtube.com/embed/live_stream?channel=' + value + '&autoplay=1&mute=1'
    }
    
    function embedTwitchChannel(value) {
      return 'https://player.twitch.tv/?channel=' + value + '&parent=' + hostDomain + '&autoplay=true&muted=true&height=100%&width=100%'
    }
    
    function embedTwitchVideo(value, extras) {
      return 'https://player.twitch.tv/?video=' + value + '&parent=' + hostDomain + '&autoplay=true&muted=true&height=100%&width=100%' + extras
    }

    function embedAlias(value, extras) {
      var streamer = global.aliases[value]
      if (streamer.status) {
        return checkEmbeds(streamer.status.type, streamer.status.value, [])
      }
      else {
        return checkEmbeds(streamer.streams[0].type, streamer.streams[0].value, [])
      }
    }

    function resolveEmbedData(type, value, extras) {
      if (type == 'alias') {
        var streamer = global.aliases[value]
        if (streamer.status) {
          type = streamer.status.type
          value = streamer.status.value
        }
        else {
          type = streamer.streams[0].type
          value = streamer.streams[0].value
        }
      }
      return [type, value, extras]
    }
    
    function checkReferers(str) {
      /* Check if data is embedded in the string */
      var [type, value] = str.split('=')
      if (type in getEmbeds()) {
        return [type, value, []]
      }
      
      /* Try each method for something that isn't null */
      for (referFun of getReferFunctions()) {
        var result = referFun(str)
        if (result) {
          return result
        }
      }
      
      return [null, null, null]
    }
    
    function checkEmbeds(type, value, extras) {
      return getEmbeds()[type](value, extras)
    }
    
    function createGrid(forcePrompt = false) {
      var params = new URLSearchParams(window.location.search)
      
      /* Build the grid based on the URL, prompt if unavailable */
      var rows = params.get('rows')
      if (rows == null || forcePrompt) {
        /* Horrible check to keep prompting until a valid number is entered */
        do {
          rows = prompt('Rows:')
          
          /* Allow cancellation if the page has already been loaded */
          if (rows == null && grid.children.length != 0) {
            return
          }
        } while (!(Number(rows) >= 1))
      }
      var columns = params.get('columns')
      if (columns == null || forcePrompt) {
        /* Horrible check to keep prompting until a valid number is entered */
        do {
          columns = prompt('Columns:')
          
          /* Allow cancellation if the page has already been loaded */
          if (columns == null && grid.children.length != 0) {
            return
          }
        } while (!(Number(columns) >= 1))
      }
      
      var totalElements = rows * columns
      
      /* Show the help dialog if the URL is empty */
      if (Array.from(params).length == 0) {
        toggleOverlayHelp()
      }
      
      /* Update the css to actually display a grid */
      grid.style.gridTemplateRows    = 'repeat(' + rows    + ', minmax(0, 1fr))'
      grid.style.gridTemplateColumns = 'repeat(' + columns + ', minmax(0, 1fr))'
      
      /* Add bookkeeping */
      grid.rows = rows
      grid.columns = columns
      
      /* If children don't exist yet, this is a fresh page load */
      var freshGrid = grid.children.length == 0
      
      /* Pad out the grid using blank elements */
      while (grid.children.length < totalElements) {
        grid.appendChild(makeBlankElement())
      }
      
      if (freshGrid) {
        /* Fill in the grid using the URL */
        var currentElement = 0
        var extras = ''
        params.forEach(function(value, key) {
          if (currentElement < totalElements)
          {
            var [tempType, tempValue, tempExtras] = checkReferers(key)
            if (key in getEmbeds()) {
              /* Extra data will precede the embed type to make parsing easier */
              setElement(grid.children[currentElement], key, value, extras)
              extras = ''
              ++currentElement
            } else if (tempType || tempValue || tempExtras) {
              /* Found something, load it */
              setElementFromString(grid.children[currentElement], key)
              extras =''
              ++currentElement
            }
            else if (getReserved().includes(key)) {
              /* Do nothing for reserved keywords */
            }
            else {
              /* Otherwise, must be part of the extra data */
              extras += '&' + key + '=' + value
            }
          }
        })
      } else {
        /* If an element is about to be cut off, move it to the first available blank spot */
        for (var afterIndex = totalElements; afterIndex < grid.children.length; ++afterIndex) {
          /* Swap non-blank trailing elements... */
          if (grid.children[afterIndex].type != 'blank') {
            /* With... */
            for (var currentIndex = 0; currentIndex < totalElements; ++currentIndex) {
              /* Any blank leading elements */
              if (grid.children[currentIndex].type == 'blank') {
                moveElement(grid.children[afterIndex], grid.children[currentIndex])
              }
            }
          }
        }
        
        /* Cut off elements that couldn't fit */
        while (grid.children.length > totalElements) {
          grid.removeChild(grid.lastChild)
        }
      }
      
      /* Grid is created, go ahead and update the URL */
      updateURL()
      
      /* Size the grid elements correctly */
      resizeGrid()
    }

    function adaptMouseToTouch(fun) {
      return function(e) {
        if (e.touches[0]) {
          e.touches[0].button = 0
        }
        fun(e.touches[0])
      }
    }

    function makeGesturable(element, callback) {
      element.onmousedown = function(event) {
        gestureMouseDown(element, event, callback)
      }
      element.ontouchstart = adaptMouseToTouch(element.onmousedown)
    }
    
    function gestureMouseDown(element, event) {
      /* Left mouse only */
      if (event.button == 0) {
        gestureStartTime = (new Date()).getTime()
        gestureStartX = event.clientX
        gestureStartY = event.clientY
        
        handleStreamGesture(element, event)

        window.onmouseup = function(event) {
          gestureMouseUp(element, event)
        }
        window.ontouchend = adaptMouseToTouch(window.onmouseup)

        window.onmousemove = function(event) {
          gestureMouseMove(element, event)
        }

        window.ontouchmove = adaptMouseToTouch(window.onmousemove)

        /* Ensure a long press is registered and displayed if the mouse doesn't move */
        gestureTimeout = setTimeout(() => {
          handleStreamGesture(element, event)
        }, 800);
      }
    }
    
    function gestureMouseUp(element, event) {
      handleStreamGesture(element, event)

      /* Left mouse only */
      if (event == null || event.button == 0) {
        setElementFromClick(element)
        window.onmouseup = null
        window.onmousemove = null
        window.ontouchend = null
        window.ontouchmove = null
      }
    }
    
    function gestureMouseMove(element, event) {
      handleStreamGesture(element, event)
    }

    function handleStreamGesture(element, event) {
      /* Clear the long press timer */
      if (typeof gestureTimeout != 'undefined') {
        clearTimeout(gestureTimeout)
      }

      var gestureX = event.clientX - gestureStartX
      var gestureY = event.clientY - gestureStartY
      var gestureDuration = (new Date()).getTime() - gestureStartTime

      var distance = Math.sqrt(gestureX * gestureX + gestureY * gestureY)
      var angle = 180.0 + Math.atan2(gestureX, gestureY) * 180.0 / Math.PI

      var key = ' '
      if (distance < 50) {       // Neutral
        if (element.lastChild.tagName == 'DIV') { // Blank element
          key = 's'
        } else if (gestureDuration > 800) { // Do nothing with long press in center
          key = ''
        }
      } else if (angle < 45.0) {  // Up
        key = 'd'
      } else if (angle < 135.0) { // Left
        key = 'j'
      } else if (angle < 225.0) { // Down
        key = 's'
      } else if (angle < 315.0) { // Right
        key = 'k'
      } else if (angle < 360.0) { // Up
        key = 'd'
      }

      myKeyDown({ key: key })
    }
    
    function makeBlankElement() {
      var div = document.createElement('div')
      
      /* Add event listeners */
      makeGesturable(div)
      div.ondrop     = function (event) { setElementFromDrop(div, event) }
      div.ondragover = function (event) { event.preventDefault() }
      
      /* Add bookkeeping */
      div.classList.add('grid-element')
      div.type = 'blank'
      div.setAttribute('type', 'blank')
      
      /* First child is the box/text displayed on hover */
      var gridOverlay = div.appendChild(document.createElement('div'))
      gridOverlay.classList.add('grid-overlay')
      gridOverlay.appendChild(document.createElement('div'))
      gridOverlay.addEventListener('mousemove', function(e) {
        e.target.classList.remove('fade')
        
        if (e.interactTimeout) {
          clearTimeout(e.interactTimeout)
        }
        e.target.interactTimeout = setTimeout(function() {
          e.target.classList.add('fade')
        }, 2000)
      })

      /* Second child is shown when cycling between next/prev */
      var gridStatus = gridOverlay.appendChild(document.createElement('div'))
      gridStatus.classList.add('grid-status')

      /* Last child is the actual content */
      div.appendChild(document.createElement('div'))
      
      /* Add extra variables */
      div.channelNameTimeout = null
      return div
    }
    
    function setElement(element, type, value, extras) {
      /* Can only set non-null elements with a non-null type */
      if (element && type) {                    
        /* Clear the element if blank, otherwise construct the embed based on the type/value */
        if (type == 'blank') {
          removeElement(element)
        } else {
          /* Add bookkeeping */
          element.type = type
          
          /* Ignore value if blank */
          if (value) {
            element.value = value
          } else {
            element.value = null
          }
          
          /* Ignore extras if blank */
          if (extras) {
            element.extras = extras
          } else {
            element.extras = null
          }

          var [realType, realValue, realExtras] = resolveEmbedData(type, value, extras)
          realType ? element.setAttribute('type', realType) : element.removeAttribute('type')
          realValue ? element.setAttribute('value', realValue) : element.removeAttribute('value')
          realExtras ? element.setAttribute('extras', realExtras) : element.removeAttribute('extras')

          
          /* Create and set up the iframe */
          var frame = document.createElement('iframe')
          frame.setAttribute('src', checkEmbeds(type, value, extras))
          frame.setAttribute('allow', 'fullscreen')
          
          /* last child is the actual content */
          element.replaceChild(frame, element.lastChild)
          
          /* Element was modified, update the URL */
          updateURL()
        }
      }
    }
    
    function updateURL() {
      /* Throw away any existing parameters */
      var baseURL = window.location.href.split('?')[0]
      
      /* Add parameters for rows/columns */
      baseURL += '?rows='    + grid.rows
      baseURL += '&columns=' + grid.columns

      /* Save backend location in URL if it isn't the default value */
      if (backendLocation.toLowerCase() != 'localhost:8080') {
        baseURL += '&backend=' + backendLocation
      }
      
      /* Add parameters for the types/value of each piece of the grid */
      document.querySelectorAll('.grid-element').forEach(function(element) {
        var extras = element.extras ?? ''
        baseURL += extras ? extras : ''
        
        var type  = element.type
        baseURL += '&' + type
        
        var value = element.value
        baseURL += value ? '=' + value : ''
      })
      
      /* Actually replace the URL */
      window.history.replaceState('', '', baseURL)
      
      updateChat()
    }

    function populateChat() {
      var select = chat.children[1]
      select.onchange = function(event) {
        if (event.target.value == 'None') {
          chat.replaceChild(document.createElement('div'), chat.lastChild)
        } else {
          chat.replaceChild(document.createElement('iframe'), chat.lastChild)
          
          var [type, value] = event.target.value.split('=')
          if (type == 'yt-video') {
            chat.lastChild.setAttribute('src', 'https://www.youtube.com/live_chat?v=' + value + '&embed_domain=' + hostDomain)
          }
          else if (type == 'ttv-channel') {
            chat.lastChild.setAttribute('src', 'https://www.twitch.tv/embed/' + value + '/chat?darkpopout&parent=' + hostDomain)
          }
        }
      }
    }
    
    function updateChat() {
      var select = chat.children[1]

      var gridElements = Array.from(document.querySelectorAll('.grid-element'))

      while ((select.children.length - 1) < gridElements.length) {
        select.appendChild(document.createElement('option'))
      }

      while ((select.children.length - 1) > gridElements.length) {
        select.removeChild(chat.lastChild)
      }

      for (var index = 0; index < gridElements.length; ++index) {
        var element = gridElements[index]
        var option = select.children[index + 1]

        var type  = element.getAttribute('type')
        var value = element.getAttribute('value')

        option.setAttribute('type', type)

        option.value = type + '=' + value
        option.textContent = crossReference[[type, value]] ?? option.value
      }
    }
    
    function resizeGrid() {
      var params = new URLSearchParams(window.location.search)
      var rows    = params.get('rows')
      var columns = params.get('columns')
      
      /* Use integer math to find a row/column multiple for evenly sized divs */
      var realHeight = Math.floor(window.innerHeight / rows)    * rows
      var realWidth  = Math.floor(window.innerWidth  / columns) * columns
      
      if (global.chatEnabled) {
        chatWidth = Math.floor(window.innerWidth * 0.20)
        realWidth -= chatWidth;
        
        chat.style.width = chatWidth + 'px'
        chat.style.height = window.innerHeight + 'px'
      }
      
      /* Using px avoids alignment issues */
      /* Using percents can cause tiny gaps due to rounding */
      grid.style.width  = realWidth  + 'px'
      grid.style.height = realHeight + 'px'
    }
    
    function populateOverlayHelp() {
      listElement = null
      
      var escapeDiv = document.createElement('div')
      escapeDiv.textContent = ('Esc to close')
      overlayHelp.append(escapeDiv)
      
      var helpText = ""
      for (var [key, value] of Object.entries(getActions())) {
        var helpDiv = document.createElement('div')
        helpDiv.textContent = key + ' - ' + value[0] + '\r\n'
        helpDiv.setAttribute('title', value[2])
        overlayHelp.append(helpDiv)
      }
    }
    
    function populateOverlayList() {
      listElement = null
      
      var escapeDiv = document.createElement('div')
      escapeDiv.textContent = ('Esc to close')
      overlayList.append(escapeDiv)
    }

    function updateOverlayListElements() {
      updateOverlayListGroup(overlayList, global.groups)
    }

    function updateOverlayListGroup(element, group) {
      /* Ensure each subgroup is represented */
      for (var [name, subgroup] of Object.entries(group.groups)) {
        /* Search for an existing details child with a same-named summary */
        var updatedDetails = null
        for (var subgroupDetails of element.children) {
          if (subgroupDetails.tagName == 'DETAILS' && subgroupDetails.name == name) {
            updatedDetails = subgroupDetails
            break
          }
        }

        /* If one wasn't found, add one */
        if (updatedDetails == null) {
          updatedDetails = addOverlayListSubgroup(element, name)
        }
        
        /* Recurse over the group */
        updateOverlayListGroup(updatedDetails, subgroup)
      }

      for (var [name, streamer] of Object.entries(group.streamers)) {
        /* Search for an existing same-named div */
        var updatedStreamer = null
        for (var streamerElement of element.children) {
          if (streamerElement.tagName == 'DIV' && streamerElement.name == name) {
            updatedStreamer = streamerElement
            break
          }
        }

        if (updatedStreamer == null) {
          updatedStreamer = addOverlayListStreamer(element, streamer)
          updatedStreamer.classList.add('overlayListElement')
        }

        updateOverlayListStreamer(updatedStreamer, name)
      }
    }

    function updateOverlayListStreamer(listElement, name) {
      var streamer = global.streamers[name]

      var status = streamer.status ?? null
      if (status) {
        var dTime = (status.startTime ?? 0) - (new Date().getTime() / 1000)
        var lateTime = 4 * 60 * 60 /* Treat as offline if longer than 4 hours til start time */

        var statusType = status.status == 'upcoming' && (dTime > lateTime) ? 'offline' : status.status

        listElement.setAttribute('status', statusType)
        listElement.lastChild.textContent = streamer.name + ' ' + status.title
        listElement.lastChild = status.type
        listElement.lastChild = status.value

        crossReference[[status.type, status.value]] = listElement.textContent
      }
    }

    function addOverlayListSubgroup(element, name) {
      var details = document.createElement('details')
      details.name = name

      var summary = details.appendChild(document.createElement('summary'))
      summary.textContent = name
      element.append(details)

      return details
    }

    function addOverlayListStreamer(element, streamer) {
      var div = document.createElement('div')

      var child = null
      var template = document.createElement('template')

      for (var stream of streamer.streams) {
        if (stream.type == 'yt-channel') {
          template.innerHTML = '<span>[YT]</span>'
        } else if (stream.type == 'ttv-channel') {
          template.innerHTML = '<span>[TTV]</span>'
        } else {
          template.innerHTML = null
        }

        if (template.innerHTML) {
          child = div.appendChild(template.content.firstChild)
          addOverlayStreamerInteraction(child, stream.type, stream.value)
        }
      }

      div.alias = streamer.aliases[0]
      template.innerHTML = '<span>' + streamer.name + '</span>'
      child = div.appendChild(template.content.firstChild)
      addOverlayStreamerInteraction(child, 'alias', streamer.aliases[0])

      div.name = streamer.name    
      
      return element.appendChild(div)
    }

    function addOverlayStreamerInteraction(element, type, value) {
      element.type = type
      element.value = value

      element.onclick = function(event){ 
        setElement(listElement, event.target.type, event.target.value, [])

        toggleOverlayInput(false)
        
        /* Refresh automatic removal */
        setOverlayAutoRemoveTimer()
      }

      element.onmousedown = function(event) { 
        /* Needed to allow dragging from list elements without moving the list */
        event.stopPropagation()
        /* Treat this as an interaction to prevent the overlay from timing out */
        setOverlayAutoRemoveTimer()
        /* Disable interactions to allow dropping onto iframes */
        disableStreamInteractions()
      }
      element.onmouseup = resetInteractions

      /* Allow the element to be dragged */
      element.setAttribute('draggable', true)
      element.ondragstart = function(event) {
        /* Use the stream data as the drop data */
        event.dataTransfer.setData('text/plain', event.target.type + '=' + event.target.value)
      }
      element.ondragend = resetInteractions

      return element
    }
    
    function populateOverlaySettings() {
      /* Disable key presses while the forms have focus */
      overlaySettings.addEventListener('focusin', function() { setKeyEvents(false) })
      overlaySettings.addEventListener('focusout', function() { setKeyEvents(true) })
      
      var div = overlaySettings.appendChild(document.createElement('div'))
      overlaySettings.lastChild.textContent = 'Esc to close'
      
      var form = overlaySettings.appendChild(document.createElement('form'))
      form.onsubmit = function(e) { e.preventDefault() }
      
      backendInput = addOverlaySetting(form, 'Backend', 'checkbox', connectBackend)

      backendLocationSetting = addOverlaySetting(form, 'Backend Location', 'text', updateBackendLocation)
      backendLocationSetting.value = backendLocation

      backendRestartSetting = addOverlaySetting(form, 'Restart Backend', 'button', null)
      backendRestartSetting.addEventListener('click', requestBackendRestart)

      backendUpdateSetting = addOverlaySetting(form, 'Update Backend', 'button', null)
      backendUpdateSetting.addEventListener('click', requestBackendAutoUpdate)
      
      overlayTimeoutInput = addOverlaySetting(form, 'Overlay Timeout', 'number', function(e) { overlayTimeoutSeconds = e.target.value; setOverlayAutoRemoveTimer() })
      overlayTimeoutInput.value = overlayTimeoutSeconds = 0
    }

    function populateOverlayMod() {
      /* Disable key presses while the forms have focus */
      overlayMod.addEventListener('focusin', function() { setKeyEvents(false) })
      overlayMod.addEventListener('focusout', function() { setKeyEvents(true) })
      
      var div = overlayMod.appendChild(document.createElement('div'))
      overlayMod.lastChild.textContent = 'Esc to close'
      
      var form = overlayMod.appendChild(document.createElement('form'))
      form.onsubmit = function(e) { e.preventDefault() }

      global.mod = {}
      global.mod.name = addOverlaySetting(form, 'Name', 'text', null)
      global.mod.group = addOverlaySetting(form, 'Group', 'text', null)
      global.mod.stream1 = addOverlaySetting(form, 'Stream', 'text', null)
      global.mod.stream2 = addOverlaySetting(form, 'Stream', 'text', null)
      global.mod.aliases = addOverlaySetting(form, 'Aliases', 'text', null)

      var accept = global.mod.accept = addOverlaySetting(form, null, 'button', null)
      accept.value = 'Add Streamer'
      accept.onclick = addStreamer

      var dump = addOverlaySetting(form, null, 'button', null)
      dump.value = 'Dump JSON'
      dump.onclick = dumpStreamersToPrompt

      var load = addOverlaySetting(form, null, 'button', null)
      load.value = 'Load JSON'
      load.onclick = loadStreamersFromPrompt
    }

    function dumpStreamersToPrompt() {
      var values = Object.values(global.streamers)
      console.log(values)
      prompt('JSON Dump of Streamers', JSON.stringify(values, null, 4))
    }

    function loadStreamersFromPrompt() {
      var load = prompt()
      if (load) {
        global.streamers = new Map()
        global.aliases = new Map()
        global.groups = { groups : {}, streamers : new Map() }

        updateStreamers(JSON.parse(load))

        if (backendSocket.readyState == WebSocket.OPEN) {
          backendSocket.close()
          setTimeout(() => {
            connectBackend()
          }, 1000);
        }
      }
    }

    function toggleOverlayMod() {
      toggleOverlay(overlayMod)
      return true
    }

    function addStreamer() {
      var streamer = {
        name : '',
        groups : [],
        streams : [],
        aliases : [],
      }

      streamer.name = global.mod.name.value
      if (global.streamers[streamer.name]) {
        alert(streamer.name + ' already exists!')
        return
      }

      streamer.groups = [global.mod.group.value.split(',').map(e => e.trim()).filter(e => e)]

      var [type, value, extras] = checkReferers(global.mod.stream1.value)
      if (type && value) {
        streamer.streams.push({
          type : type,
          value : value,
        })
      }

      var [type, value, extras] = checkReferers(global.mod.stream2.value)
      if (type && value) {
        streamer.streams.push({
          type : type,
          value : value,
        })
      }

      streamer.aliases =  global.mod.aliases.value.split(',').map(e => e.trim().toLowerCase()).filter(e => e)

      updateStreamers([streamer])
      
      backendSocket.send(JSON.stringify({
        messageType : 'initUpdate',
        version : supportedBackendVersion,
        streamer : streamer,
      }))
    }
    
    function addOverlaySetting(form, name, type, fun) {
      var label = form.appendChild(document.createElement('label'))
      label.textContent = name
      
      var input = form.appendChild(document.createElement('input'))
      input.type = type
      input.onchange = fun
      
      /* Leave checkboxes at default width */
      if (input.type != 'checkbox') {
        input.style.width = '100px'
      }
      
      /* Line break after each input option */
      form.appendChild(document.createElement('br'))
      
      return input
    }
    
    function setKeyEvents(enabled) {
      if (enabled) {
        window.onkeydown = myKeyDown
        window.onkeyup = myKeyUp
      } else {
        window.onkeydown = null
        window.onkeyup = null
      }
    }
    
    function allowStreamInteractions() {
      document.querySelectorAll('.grid-overlay').forEach(function(frame) {
        frame.classList.add('disabled')
      })

      document.querySelectorAll('iframe').forEach(function(e) {
        e.blur()
      })

      if (global.interactTimeout) {
        clearTimeout(global.interactTimeout)
      }
      global.interactTimeout = setTimeout(disableStreamInteractions, 4000);

      return true
    }

    function disableStreamInteractions() {
      document.querySelectorAll('.grid-overlay').forEach(function(frame) {
        frame.classList.remove('disabled')
      })
    }
    
    function resetInteractions() {
      /* Reset the global state used for tracking keys/clicks */
      lastKey = null
      lastElementClicked = null
      firstElementKey = null
      
      /* Clear the text */
      document.querySelectorAll('.grid-overlay :first-child').forEach(function(text) {
        text.textContent = ''
      })
    }
    
    function getActions() {
      /* Functions here must return true/false */
      /* Returning true will clear the interactions currently being tracked */
      /* Returning false should only be used if further selections are needed */
      /* e.g. Move/Copy require multiple inputs */
      var dict = {
        'h'  : ['help',          toggleOverlayHelp,       'Toggles the help overlay'],
        'l'  : ['list',          toggleOverlayList,       'Toggles the stream list overlay'],
        's'  : ['switch',        setElementFromPrompt,    'Prompts to select a new stream'],
        'n'  : ['next',          nextElement,             'Skips to the next stream within the current group'],
        'p'  : ['previous',      previousElement,         'Skips to the previous stream within the current group'],
        'j'  : ['next+',         nextGlobalElement,       'Skips to the next stream, regardless of current group'],
        'k'  : ['previous+',     previousGlobalElement,   'Skips to the previous stream, regardless of current group'],
        'd'  : ['delete',        removeElement,           'Removes the stream'],
        'm'  : ['move',          moveElement,             'Moves the stream between locations'],
        'c'  : ['chat',          toggleChat,              'Toggles the chat panel'],
        'r'  : ['reload',        reloadElement,           'Reloads the stream'],
        'f'  : ['fullscreen',    toggleFullscreen,        'Toggles fullscreen'],
        'a'  : ['adjust layout', adjustLayout,            'Prompts to select new row/column inputs'],
        'b'  : ['backend',       connectBackend,          'Connects to a background service for fetching video data'],
        '`'  : ['settings',      toggleOverlaySettings,   'Toggles the settings menu'],
        '\\' : ['modify list',   toggleOverlayMod,        'Toggles the window for modifying the streamer list'],
        ' '  : ['interact',      allowStreamInteractions, 'Disable page interactions and allow access to the stream']
      }
      return dict
    }
    
    function                   setElementFromClick(element) {
      /* Do nothing if no click action */
      if (!lastKey) {
        return
      }

      /* Find an action, otherwise just prompt for a new embed */
      var action = setElementFromPrompt
      if (lastKey in getActions()) {
        action = getActions()[lastKey][1]
      }
      
      /* Save the last element clicked to use with the action */
      lastElement = lastElementClicked
      
      /* Set the last element clicked now in case the action needs to change it */
      lastElementClicked = element
      
      /* Do something with the elements, extra arguments will be discarded naturally */
      if (action(element, lastElement)) {
        /* Action succeeded when true, reset interactions */
        resetInteractions()
      }
      
      /* Don't reset everything after a click, just the element from a key press */
      firstElementKey = null
    }
    
    function setElementFromKey(element, key) {
      /* Find an action, otherwise do nothing */
      if (key in getActions()) {
        /* Do something with the elements, extra arguments will be discarded naturally */
        if (getActions()[key][1](element, firstElementKey)) {
          /* Action succeeded when true, reset interactions */
          resetInteractions()
        }
      }
    }
    
    function setElementFromDrop(element, event) {
      /* Prevent the default action that reloads the page with the dropped link */
      event.preventDefault()
      
      /* Extract the text from the drop event */
      setElementFromString(element, event.dataTransfer.getData('text/plain'))
    }
    
    function setOverlayAutoRemoveTimer() {
      /* Reset any ongoing timeout before starting a new one*/
      if (typeof overlayTimeout != 'undefined') {
        clearTimeout(overlayTimeout)
      }
      
      if (overlayTimeoutSeconds > 0) {
        overlayTimeout = setTimeout(hideOverlays, overlayTimeoutSeconds * 1000)
      }
      return true
    }
    
    function setElementFromPrompt(element) {
      if (element && element.classList.contains('grid-element')) {
        listElement = element
        toggleOverlayInput(true)
      }
      return true
    }
    
    function setElementFromString(element, str) {
      if (element && element.classList.contains('grid-element')) {
        var [type, value, extras] = checkReferers(str)
        setElement(element, type, value, extras)
      }
    }
    
    function removeElement(element) {
      if (element && element.classList.contains('grid-element')) {
        grid.replaceChild(makeBlankElement(), element)
        
        /* Element was modified, update the URL */
        updateURL()
      }
      
      return true
    }
    
    function reloadElement(element) {
      if (element && element.classList.contains('grid-element')) {
        /* Reuse the existing data from the element */
        setElement(element, element.type, element.value, element.extras)
        return true
      }
    }
    
    function moveElement(currentElement, lastElement) {
      if (currentElement && currentElement.classList.contains('grid-element') && lastElement && lastElement.classList.contains('grid-element')) {
        if (currentElement != lastElement) {
          /* Save the last element */
          var lastType   = lastElement.type
          var lastValue  = lastElement.value
          var lastExtras = lastElement.extras
          
          /* Set last element from the current */
          setElement(lastElement, currentElement.type, currentElement.value, currentElement.extras)
          
          /* Set the current element from the last */
          setElement(currentElement, lastType, lastValue, lastExtras)
        }
        return true
      }
      return false
    }
    
    function copyElement(currentElement, lastElement) {
      if (currentElement && currentElement.classList.contains('grid-element') && lastElement && lastElement.classList.contains('grid-element')) {
        if (currentElement != lastElement) {
          /* Set the element using the data from the last element */
          setElement(currentElement, lastElement.type, lastElement.value, lastElement.extras)
        }
        return true
      }
      return false
    }
    
    function myKeyDown(event) {
      var key = event.key.toLowerCase()
      
      /* Disallow any modifiers that aren't shift */
      if (event.ctrlKey || event.altKey || event.metaKey) {
        return
      }
      
      /* Special case for escape to close the overlay */
      if (key == 'escape') {
        hideOverlays()
        resetInteractions()
        return
      }
      
      if (lastKey != key) {
        /* Save the pressed key */
        lastKey = key
        
        /* Grab whatever is underneath when an action is started */
        firstElementKey = document.querySelector('.grid-element:hover')
        
        /* Disable interactions via css to allow for click events to reach the parent div */
        disableStreamInteractions()
        
        /* Add the overlay text for the active action */
        var content = ''
        if (lastKey in getActions()) {
          content = getActions()[lastKey][0] ?? ''
        }

        document.querySelectorAll('.grid-overlay :first-child').forEach(function(overlay) {
          overlay.textContent = content
        })
      }
    }
    
    function myKeyUp(event) {
      var key = event.key.toLowerCase()
      
      /* Ignore release events that weren't the first key pressed */
      if (key == lastKey) {
        /* Complete the action with whatever is under the mouse */
        setElementFromKey(document.querySelector('.grid-element:hover'), lastKey)
        
        lastKey = null
      }
    }
    
    function findAdjacentEntry(list, entry, offset) {
      var divList = []
      for (var element of list) {
        if (element.tagName == 'DIV') {
          /* Add the current entry */
          if (element == entry) {
            divList.push(element)
            continue
          }

          /* Add any entries that aren't offline */
          if (element.getAttribute('status') != 'offline') {
            divList.push(element)
            continue
          }

          if (element.getAttribute('status') == null) {
            divList.push(element)
            continue
          }
        }
      }

      var elementIndex = 0
      for (var element of divList) {
        if (element == entry) {
          /* Add the array length to help with negative offsets */
          return divList[(elementIndex + divList.length + offset) % divList.length].name
        }
        ++elementIndex
      }
      return null
    }
    
    function setChannelNameTimer(element, name) {
      /* Set the name */
      element.firstChild.lastChild.textContent = name.charAt(0).toUpperCase() + name.slice(1)
      
      /* Clear any existing timers */
      if (element.channelNameTimeout != null) {
        clearTimeout(element.channelNameTimeout)
      }
      
      /* Create a new one remove the text */
      element.channelNameTimeout = setTimeout(
      function() {
        element.firstChild.lastChild.textContent = ''
      }, 1000
      )
    }

    function findStreamer(type, value) {
      if (type == 'alias') {
        return global.aliases[value]
      }

      for (var streamer of Object.values(global.streamers)) {
        if (streamer.status && streamer.status.type == type && streamer.status.value == value) {
          return streamer
        }

        for (var stream of streamer.streams) {
          if (stream.type == type && stream.value == value) {
            return streamer
          }
        }
      }

      return null
    }

    function findListElementFromGridElement(element) {
      var streamer = null
      streamer = streamer ?? findStreamer(element.type, element.value)
      streamer = streamer ?? findStreamer(element.getAttribute('type'), element.getAttribute('value'))

      if (streamer) {
        for (var listElement of document.querySelectorAll('.overlayListElement')) {
          if (streamer.name == listElement.name) {
            return listElement
          }
        }
      }

      return null
    }
    
    function nextElement(element) {
      if (element && element.classList.contains('grid-element')) {
        var listElement = findListElementFromGridElement(element)

        var name = null
        if (listElement) {
          name = findAdjacentEntry(listElement.parentElement.children, listElement, 1)
        }

        /* Default to the first streamer if nothing can be found */
        name = name ?? Object.values(global.streamers)[0].name

        setElementFromString(element, global.streamers[name].aliases[0])
        setChannelNameTimer(element, name)
      }
      return true
    }
    
    function previousElement(element) {
      if (element && element.classList.contains('grid-element')) {
        var listElement = findListElementFromGridElement(element)

        var name = findAdjacentEntry(
          overlayList.querySelectorAll('.overlayListElement'), listElement, -1
        )

        /* Default to the first streamer if nothing can be found */
        name = name ?? Object.values(global.streamers)[0].name

        setElementFromString(element, global.streamers[name].aliases[0])
        setChannelNameTimer(element, name)
      }
      return true
    }
    
    function nextGlobalElement(element) {
      if (element && element.classList.contains('grid-element')) {
        var listElement = findListElementFromGridElement(element)

        var name = findAdjacentEntry(
          overlayList.querySelectorAll('.overlayListElement'), listElement, 1
        )

        /* Default to the first streamer if nothing can be found */
        name = name ?? Object.values(global.streamers)[0].name

        setElementFromString(element, global.streamers[name].aliases[0])
        setChannelNameTimer(element, name)
      }
      return true
    }
    
    function previousGlobalElement(element) {
      if (element && element.classList.contains('grid-element')) {
        var listElement = findListElementFromGridElement(element)

        var name = findAdjacentEntry(
          overlayList.querySelectorAll('.overlayListElement'), listElement, -1
        )

        /* Default to the first streamer if nothing can be found */
        name = name ?? Object.values(global.streamers)[0].name

        setElementFromString(element, global.streamers[name].aliases[0])
        setChannelNameTimer(element, name)
      }
      return true
    }
    
    function toggleFullscreen(element) {
      if (element && element.classList.contains('grid-element')) {
        /* Only fullscreen iframes */
        if (document.fullscreenElement == null) {
          if (element.lastChild.tagName.toLowerCase() == 'iframe') {
            element.lastChild.requestFullscreen()
          }
        }
        else {
          document.exitFullscreen()
        }
      }
      return true
    }
    
    function adjustLayout() {
      /* Recreate the grid and prompt for new row/column inputs */
      createGrid(true)
      
      /* Ensure the overlays are hidden to clear out lingering references to elements */
      hideOverlays()
      
      return true
    }

    function toggleOverlay(overlay) {
      /* Toggle the element passed in, if it exists */
      if (overlay) {
        if (overlay.style.display == 'none') {
          /* Reposition the window when it gets shown */
          overlay.style.display = 'inline-block'
          overlay.style.top = '2%'
          overlay.style.left = '2%'
          
          /* Refresh automatic removal */
          setOverlayAutoRemoveTimer()
        } else {
          overlay.style.display = 'none'
        }
      }
    }
    
    function toggleOverlays(overlay) {
      /* Disable everything */
      for (var element of document.querySelectorAll('.overlay')) {
        element.style.display = 'none'
      }
      
      /* Toggle the element passed in */
      toggleOverlay(overlay)
    }
    
    function toggleOverlayHelp() {
      toggleOverlays(overlayHelp)
      return true
    }
    
    function toggleOverlayList(element) {
      toggleOverlays(overlayList)
      listElement = element
      return true
    }
    
    function toggleOverlaySettings(element) {
      toggleOverlays(overlaySettings)
      return true
    }
    
    function hideOverlays() {
      /* Reset the overlay elements */
      listElement = null
      toggleOverlays(null)
      return true
    }
    
    function toggleChat(e) {
      global.chatEnabled = !global.chatEnabled

      if (global.chatEnabled) {
        chat.removeAttribute('style')
      } else {
        chat.setAttribute('style', 'display: none')
      }

      resizeGrid()

      return true
    }

    function updateBackendLocation(e) {
      backendLocation = e.target.value
      updateURL()
    }
    
    function requestBackendData(sock) {
      if (sock.readyState != WebSocket.CLOSED) {
        var initData = Object.values(global.streamers)
        initData = initData.length > 0 ? initData : JSON.parse(streamerData.innerHTML)

        sock.send(JSON.stringify({
          messageType : 'init',
          version : supportedBackendVersion,
          initData : initData,
        }))

        /* Repeat this call every minute */
        setTimeout(() => {
          requestBackendData(sock)
        }, 1 * 60 * 1000)
      }
    }
    
    function connectBackend() {
      if (typeof backendSocket == 'undefined' || backendSocket.readyState == WebSocket.CLOSED) {
        backendSocket = new WebSocket('ws://' + backendLocation)
        backendSocket.onopen = function() { requestBackendData(backendSocket) }
        backendSocket.onmessage = processBackendResponse
        
        /* Set up the backend error message on second connection attempt */
        /* This prevents spurious errors if the backend failed on initial page load */
        if (typeof firstAttempt == 'undefined') {
          firstAttempt = true
        } else {
          firstAttempt = false
        }
        
        /* Update the settings menu checkbox */
        backendInput.checked = true
        backendSocket.onclose = function() { backendInput.checked = false }
        backendSocket.onerror = function() { 
          initializePage()
          if (firstAttempt == false) {
            alert('Backend encountered a problem connecting to: ' + backendLocation)
          }
        }
      } else {
        backendSocket.close()
        
        /* Update the settings menu checkbox */
        backendInput.checked = false
      }

      setTimeout(function() {
        if (backendSocket.readyState != WebSocket.OPEN) {
          console.log('Too slow')
          backendSocket.close()
        }
      }, 500)

      return true
    }

    function requestBackendRestart() {
      backendSocket.send(JSON.stringify({
        messageType : 'restart',
        version : supportedBackendVersion,
        restart : true
      }))
    }

    function requestBackendAutoUpdate() {
      backendSocket.send(JSON.stringify({
        messageType : 'autoUpdate',
        version : supportedBackendVersion,
        autoUpdate : true
      }))
    }
    
    function processBackendResponse(response) {
      var message = JSON.parse(response.data)

      if (message.messageType == 'init') {
        processInitMessage(message)
      } else if (message.messageType == 'update') {
        processUpdateMessage(message)
      }
    }

    function checkMessageVersion(message) {
      var version = message.version

      var sameVersion = true
      for (var i = 0; i < 3; ++i) {
        if (version[i] != supportedBackendVersion[i]) {
          sameVersion = false
        }
      }

      /* Only update if the versions match, otherwise notify the user */
      /* TODO: Proper backwards compatibility */ 
      if (!sameVersion) {
        alert('Your backend is out of date. Please update from the settings menu.')
      }

      return sameVersion
    }

    function processInitMessage(init) {
      if (checkMessageVersion(init)) {
        initializePage(init.initData)
      } else {
        initializePage()
      }
    }

    function processUpdateMessage(update) {
      /* Search for the updated streamer */
      var updatedStreamer = global.streamers[update.name] ?? null

      /* Add a new streamer if none was found */
      if (updatedStreamer == null) {
        updatedStreamer = {
          name : update.name,
          groups : [],
          videos : [],
        }
        global.streamers[update.name] = updatedStreamer
      }

      /* Update each video in the message */
      for (var video of update.videos) {
        var foundVideo = false
        for (var stream of updatedStreamer.streams) {
          if (video.type == stream.type && video.value == stream.value) {
            foundVideo = true
            break
          }
        }

        if (!foundVideo) {
          updatedStreamer.streams.push({
            type : video.type,
            value : video.value,
          })
        }
      }

      for (var video of update.videos) {
        if (video.status == 'live') {
          updatedStreamer.status = video
          return
        }
      }

      for (var video of update.videos) {
        if (video.status == 'upcoming') {
          updatedStreamer.status = video
          return
        }
      }

      updatedStreamer.status = {
        status : 'offline'
      }
    }

    function maintainGridElement(element) {
      var type = element.type
      var value = element.value

      for (var streamer of Object.values(global.streamers)) {
        for (var stream of streamer.streams) {
          if (stream.type != type || stream.value != value) {
            continue
          }

          if ('status' in streamer && streamer.status.status == 'offline') {
            removeElement(element)
          } else if ('status' in streamer && streamer.status.status != 'offline') {
            element.type = streamer.status.type
            element.value = streamer.status.value
          }
          
          return
        }
      }
    }

    function maintainVideoElements() {
      for (var element of document.querySelectorAll('.grid-element')) {
        maintainGridElement(element)
      }

      updateURL()
      updateChat()
    }
    
    function makeDraggable(element) {
      element.onmousedown = function(event) {
        dragMouseDown(element, event)
      }
    }
    
    function dragMouseDown(element, event) {
      /* Left mouse only */
      if (event.button == 0) {
        /* Disable interactions via css to allow for keep dragging smooth */
        disableStreamInteractions()
        
        dragStartX = event.clientX
        dragStartY = event.clientY
        
        window.onmouseup = function(event) {
          dragMouseUp(element, event)
        }
        window.onmousemove = function(event) {
          dragMouseMove(element, event)
        }
      }
      
      /* If an overlay is manipulated, refresh automatic removal */
      if (element.classList.contains('overlay')) {
        setOverlayAutoRemoveTimer()
      }
    }
    
    function dragMouseUp(element, event) {
      /* Left mouse only */
      if (event == null || event.button == 0) {
        /* Allow interactions again */
        resetInteractions()
        
        window.onmouseup = null
        window.onmousemove = null
      }
      
      /* If an overlay is manipulated, refresh automatic removal */
      if (element.classList.contains('overlay')) {
        setOverlayAutoRemoveTimer()
      }
    }
    
    function dragMouseMove(element, event) {
      var dragX = event.clientX - dragStartX
      var dragY = event.clientY - dragStartY
      
      var box = element.getBoundingClientRect()
      
      /* Terrible looking clamp code*/
      /* Ensures the element stays entirely within the window */
      dragX = Math.min(Math.max(dragX, -box.left), window.innerWidth - box.right)
      dragY = Math.min(Math.max(dragY, -box.top), window.innerHeight - box.bottom)
      
      element.style.left = (100 * (element.offsetLeft + dragX) / window.innerWidth)+ '%'
      element.style.top  = (100 * (element.offsetTop  + dragY) / window.innerHeight)+ '%'
      
      dragStartX = event.clientX
      dragStartY = event.clientY
      
      /* If an overlay is manipulated, refresh automatic removal */
      if (element.classList.contains('overlay')) {
        setOverlayAutoRemoveTimer()
      }
      
      /* Prevent text selection while dragging */
      event.preventDefault()
    }
    
    function updateStreamers(streamerList) {
      for (var streamer of streamerList) {
        global.streamers[streamer.name] = global.streamers[streamer.name] ?? streamer

        /* Populate list of streamers by name */
        for (var alias of streamer.aliases) {
          global.aliases[alias] = global.aliases[alias] ?? streamer
        }
        
        for (var groupSet of streamer.groups) {
          /* Create nested groups */
          var group = global.groups
          for (var subgroup of groupSet) {
            group = group.groups[subgroup] = group.groups[subgroup] ?? { groups : new Map(), streamers : new Map() }
          }
          
          /* Add streamer if it doesn't exist */
          group.streamers[streamer.name] = group.streamers[streamer.name] ?? streamer
        }
      }
    }

    function toggleOverlayInput(state) {
      if (state == true) {
        /* Want to show AND reposition AND clear the input AND focus AND clear the results*/
        overlayInput.style.display = 'inline-block';
        overlayInput.style.top = '30%'
        overlayInput.style.left = '50%'
        inputText.value = ''
        inputText.focus()

        /* Also show a blur over the entire window */
        overlayBlur.style.display = 'inline-block';

        while (inputList.firstChild) {
          inputList.removeChild(inputList.firstChild)
        }

      } else if (state == false) {
        overlayInput.style.display = 'none';
        overlayBlur.style.display = 'none';
        inputText.value = ''
      }
    }

    function populateOverlayInput() {
      overlayInput.addEventListener('focusin', function() { setKeyEvents(false) })
      overlayInput.addEventListener('focusout', function() { setKeyEvents(true) })

      inputText.addEventListener('keypress', function (e) {
        if (e.key == 'Enter') {
          if (inputList.children.length > 0)
          {
            e.preventDefault()
            setElementFromString(listElement, inputList.children[0].alias)
            inputText.blur()
            toggleOverlayInput(false)
          }
          else
          {
            e.preventDefault()
            console.log(inputText)
            setElementFromString(listElement, inputText.value)
            inputText.blur()
            toggleOverlayInput(false)
          }
        }
      })

      inputText.addEventListener('keydown', function (e) {
        if (e.key == 'Escape') {
          e.preventDefault()
          inputText.blur()
          toggleOverlayInput(false)
        }
      })

      inputText.addEventListener('focusout', function() {
        if (inputText.value.trim() == '') {
          toggleOverlayInput(false)
        }
      })

      inputText.oninput = function (e) { 
        while (inputList.firstChild) {
          inputList.removeChild(inputList.firstChild)
        }

        var searchTerms = e.target.value.split(' ').map(e => e.trim().toLowerCase()).filter(e => e)
        if (searchTerms) {
          var channelSet = new Set()
          for (var [name, channel] of Object.entries(global.streamers)) {
            /* Start with the name as filter criteria */
            var infoList = name.split(' ')

            /* Add any aliases */
            for (var alias of channel.aliases) {
              infoList.push(alias)
            }

            /* Add any groups */
            for (var group of channel.groups) {
              for (var subgroup of group) {
                infoList.push(subgroup)
              }
            }

            infoList = infoList.map(e => e.trim().toLowerCase())

            /* If online status is available, skip offline streamers */
            /* Otherwise, take anything where the beginning matches */
            var status = channel?.status?.status ?? 'live'
            if (status == 'live') {
              var matchesTerms = true
              for (var term of searchTerms) {
                var validInfo = false
                for (var info of infoList) {
                  if (info.startsWith(term)) {
                    validInfo = true
                    break
                  }
                }
                
                if (!validInfo) {
                  matchesTerms = false
                  break
                }
              }

              if (matchesTerms) {
                channelSet.add(channel)
              }
            }
          }

          /* Add using the same logic as the list */
          for (var channel of channelSet) {
            addOverlayListStreamer(inputList, channel)
          }
        }
      }
    }
    
    function setup() {
      /* Key events only work if an iframe doesn't have focus */
      window.onresize = resizeGrid
      window.onkeydown = myKeyDown
      window.onkeyup = myKeyUp
      window.onfocus = resetInteractions
      
      /* Temporary workaround, set globals here */
      global = {}

      global.streamers = new Map()
      global.aliases = new Map()
      global.groups = { groups : {}, streamers : new Map() }
      global.chatEnabled = false

      overlayTimeoutSeconds = 0
      backendLocation = new URLSearchParams(window.location.search).get('backend') || 'localhost:8080'
      crossReference = new Map()
      alreadyWarnedVersion = false
      
      populateOverlayInput()
      populateOverlayHelp()
      populateOverlayList()
      populateOverlaySettings()
      populateOverlayMod()
      populateChat()

      makeDraggable(overlayHelp)
      makeDraggable(overlayList)
      makeDraggable(overlaySettings)
      makeDraggable(overlayMod)
      makeDraggable(overlayInput)

      connectBackend()
    }

    function initializePage(streamerList) {
      global.initialized = global.initialized ?? false

      if (!global.initialized) {
        global.initialized = true

        if (streamerList && streamerList.length > 0) {
          console.log('Loading from server!')
          updateStreamers(streamerList)
        } else {
          console.log('Loading from defaults!')
          updateStreamers(JSON.parse(streamerData.innerHTML))
        }

        createGrid()
        resetInteractions()
        
        updateOverlayListElements()
        setInterval(updateOverlayListElements, 1000)

        setInterval(maintainVideoElements, 1000)
      }

    }

    window.addEventListener('load', setup)
  </script>
  <script id="streamerData" type="application/json">
    [
      {
        "name" : "Calliope Mori",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCL_qhgtOy0dy1Agp8vkySQg" }
        ],
        "aliases" : ["calliope", "calli", "mori"]
      },
      {
        "name" : "Takanashi Kiara",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCHsx4Hqa-1ORjQTh9TYDhww" }
        ],
        "aliases" : ["kiara"]
      },
      {
        "name" : "Ninomae Ina'nis",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCMwGHR0BTZuLsmjY_NT5Pwg" }
        ],
        "aliases" : ["ina'nis", "ina"]
      },
      {
        "name" : "Gawr Gura",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCoSrY_IQQVpmIRZ9Xf-y93g" }
        ],
        "aliases" : ["gura"]
      },
      {
        "name" : "Watson Amelia",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCyl1z3jo3XHR1riLFKG5UAg" }
        ],
        "aliases" : ["amelia", "ame"]
      },
      {
        "name" : "Irys",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC8rcEBzJSleTkf_-agPM20g" }
        ],
        "aliases" : ["irys", "yabairys"]
      },
      {
        "name" : "Tsukumo Sana",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCsUj0dszADCGbF3gNrQEuSQ" }
        ],
        "aliases" : ["sana"]
      },
      {
        "name" : "Ceres Fauna",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCO_aKKYxn4tvrqPjcTzZ6EQ" }
        ],
        "aliases" : ["fauna"]
      },
      {
        "name" : "Ouro Kronii",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCmbs8T6MWqUHP1tIQvSgKrg" }
        ],
        "aliases" : ["kronii"]
      },
      {
        "name" : "Nanashi Mumei",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC3n5uGu18FoCy23ggWWp8tA" }
        ],
        "aliases" : ["mumei"]
      },
      {
        "name" : "Hakos Baelz",
        "groups": [["HoloEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCgmPnx-EEeOrZSg5Tiw7ZRQ" }
        ],
        "aliases" : ["baelz", "bae"]
      },
      {
        "name" : "Tokino Sora",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCp6993wxpyDPHUpavwDFqgg" }
        ],
        "aliases" : ["sora"]
      },
      {
        "name" : "Roboco-san",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCDqI2jOz0weumE8s7paEk6g" }
        ],
        "aliases" : ["roboco"]
      },
      {
        "name" : "Sakura Miko",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC-hM6YJuNYVAmUWxeIr9FeA" }
        ],
        "aliases" : ["miko", "mikocchi"]
      },
      {
        "name" : "Hoshimachi Suisei",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC5CwaMl1eIgY8h02uZw7u8A" }
        ],
        "aliases" : ["suisei"]
      },
      {
        "name" : "AZKI",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC0TXe_LYZ4scaW2XMyi5_kw" }
        ],
        "aliases" : ["azki"]
      },
      {
        "name" : "Yozora Mel",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCD8HOxPs4Xvsm8H0ZxXGiBw" }
        ],
        "aliases" : ["mel"]
      },
      {
        "name" : "Shirakami Fubuki",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCdn5BQ06XqgXoAxIhbqw5Rg" }
        ],
        "aliases" : ["fubuki", "fbk"]
      },
      {
        "name" : "Natsuiro Matsuri",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCQ0UDLQCjY0rmuxCDE38FGg" }
        ],
        "aliases" : ["matsuri"]
      },
      {
        "name" : "Aki Rosenthal",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCFTLzh12_nrtzqBPsTCqenA" }
        ],
        "aliases" : ["aki", "akirose"]
      },
      {
        "name" : "Akai Haato",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC1CfXB_kRs3C-zaeTG3oGyg" }
        ],
        "aliases" : ["haato", "haachama"]
      },
      {
        "name" : "Minato Aqua",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC1opHUrw8rvnsadT-iGp7Cg" }
        ],
        "aliases" : ["aqua"]
      },
      {
        "name" : "Murasaki Shion",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCXTpFs_3PqI41qX2d9tL2Rw" }
        ],
        "aliases" : ["shion"]
      },
      {
        "name" : "Nakiri Ayame",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC7fk0CB07ly8oSl0aqKkqFg" }
        ],
        "aliases" : ["ayame"]
      },
      {
        "name" : "Yuzuki Choco",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC1suqwovbL1kzsoaZgFZLKg" }
        ],
        "aliases" : ["choco"]
      },
      {
        "name" : "Oozora Subaru",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCvzGlP9oQwU--Y0r9id_jnA" }
        ],
        "aliases" : ["subaru"]
      },
      {
        "name" : "Ookami Mio",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCp-5t9SrOQwXMU7iIjQfARg" }
        ],
        "aliases" : ["mio"]
      },
      {
        "name" : "Nekomata Okayu",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCvaTdHTWBGv3MKj3KVqJVCw" }
        ],
        "aliases" : ["okayu"]
      },
      {
        "name" : "Inugami Korone",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UChAnqc_AY5_I3Px5dig3X1Q" }
        ],
        "aliases" : ["korone"]
      },
      {
        "name" : "Usada Pekora",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC1DCedRgGHBdm81E1llLhOQ" }
        ],
        "aliases" : ["pekora"]
      },
      {
        "name" : "Uruha Rushia",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCl_gCybOJRIgOXw6Qb4qJzQ" }
        ],
        "aliases" : ["rushia"]
      },
      {
        "name" : "Shiranui Flare",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCvInZx9h3jC2JzsIzoOebWg" }
        ],
        "aliases" : ["flare"]
      },
      {
        "name" : "Shirogane Noel",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCdyqAaZDKHXg4Ahi7VENThQ" }
        ],
        "aliases" : ["noel", "danchou"]
      },
      {
        "name" : "Houshou Marine",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCCzUftO8KOVkV4wQG1vkUvg" }
        ],
        "aliases" : ["marine", "senchou"]
      },
      {
        "name" : "Amane Kanata",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCZlDXzGoo7d44bwdNObFacg" }
        ],
        "aliases" : ["kanata", "ppt"]
      },
      {
        "name" : "Tsunomaki Watame",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCqm3BQLlJfvkTsX_hvm0UmA" }
        ],
        "aliases" : ["watame"]
      },
      {
        "name" : "Tokoyami Towa",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC1uv2Oq6kNxgATlCiez59hw" }
        ],
        "aliases" : ["towa", "tmt"]
      },
      {
        "name" : "Himemori Luna",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCa9Y57gfeY0Zro_noHRVrnw" }
        ],
        "aliases" : ["luna"]
      },
      {
        "name" : "Kiryu Coco",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCS9uQI-jC3DE0L4IpXyvr6w" }
        ],
        "aliases" : ["coco", "kaichou"]
      },
      {
        "name" : "Yukihana Lamy",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCFKOVgVbGmX65RxO3EtH3iw" }
        ],
        "aliases" : ["lamy"]
      },
      {
        "name" : "Momosuzu Nene",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCAWSyEs_Io8MtpY3m-zqILA" }
        ],
        "aliases" : ["nene", "nenechi"]
      },
      {
        "name" : "Shishiro Botan",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCUKD-uaobj9jiqB-VXt71mA" }
        ],
        "aliases" : ["botan", "shishiron"]
      },
      {
        "name" : "Omaru Polka",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCK9V2B22uJYu3N7eR_BT9QA" }
        ],
        "aliases" : ["polka"]
      },
      {
        "name" : "La+ Darkness",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCENwRMx5Yh42zWpzURebzTw" }
        ],
        "aliases" : ["la+", "laplus"]
      },
      {
        "name" : "Takane Lui",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCs9_O1tRPMQTHQ-N_L6FU2g" }
        ],
        "aliases" : ["lui"]
      },
      {
        "name" : "Hakui Koyori",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC6eWCld0KwmyHFbAqK3V-Rw" }
        ],
        "aliases" : ["koyori"]
      },
      {
        "name" : "Sakamata Chloe",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCIBY1ollUsauvVi4hW4cumw" }
        ],
        "aliases" : ["chloe"]
      },
      {
        "name" : "Kazama Iroha",
        "groups": [["HoloJP"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC_vMYWcDjmfdpH6r4TTn1MQ" }
        ],
        "aliases" : ["iroha"]
      },
      {
        "name" : "Ayunda Risu",
        "groups": [["HoloID"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCOyYb1c43VlX9rc_lT6NKQw" }
        ],
        "aliases" : ["risu"]
      },
      {
        "name" : "Moona Hoshinova",
        "groups": [["HoloID"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCP0BspO_AMEe3aQqqpo89Dg" }
        ],
        "aliases" : ["moona"]
      },
      {
        "name" : "Airani Iofifteen",
        "groups": [["HoloID"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCAoy6rzhSf4ydcYjJw3WoVg" }
        ],
        "aliases" : ["io15", "iofi"]
      },
      {
        "name" : "Kureiji Ollie",
        "groups": [["HoloID"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCYz_5n-uDuChHtLo7My1HnQ" }
        ],
        "aliases" : ["ollie"]
      },
      {
        "name" : "Anya Melfissa",
        "groups": [["HoloID"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC727SQYUvx5pDDGQpTICNWg" }
        ],
        "aliases" : ["anya"]
      },
      {
        "name" : "Pavolia Reine",
        "groups": [["HoloID"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UChgTyjG-pdNvxxhdsXfHQ5Q" }
        ],
        "aliases" : ["reine"]
      },
      {
        "name" : "Elira Pendora",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCIeSUTOTkF9Hs7q3SGcO-Ow" }
        ],
        "aliases" : ["elira"]
      },
      {
        "name" : "Pomu Rainpuff",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCP4nMSTdwU1KqYWu3UH5DHQ" }
        ],
        "aliases" : ["pomu"]
      },
      {
        "name" : "Finana Ryugu",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCu-J8uIXuLZh16gG-cT1naw" }
        ],
        "aliases" : ["finana"]
      },
      {
        "name" : "Selen Tatsuki",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCV1xUwfM2v2oBtT3JNvic3w" }
        ],
        "aliases" : ["selen"]
      },
      {
        "name" : "Rosemi Lovelock",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC4WvIIAo89_AzGUh1AZ6Dkg" }
        ],
        "aliases" : ["rosemi"]
      },
      {
        "name" : "Petra Gurin",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCgA2jKRkqpY_8eysPUs8sjw" }
        ],
        "aliases" : ["petra"]
      },
      {
        "name" : "Reimu Endou",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCBURM8S4LH7cRZ0Clea9RDA" }
        ],
        "aliases" : ["reimu"]
      },
      {
        "name" : "Nina Kosaka",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCkieJGn3pgJikVW8gmMXE2w" }
        ],
        "aliases" : ["nina"]
      },
      {
        "name" : "Millie Parfait",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC47rNmkDcNgbOcM-2BwzJTQ" }
        ],
        "aliases" : ["millie"]
      },
      {
        "name" : "Enna Alouette",
        "groups": [["NijiEN"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCR6qhsLpn62WVxCBK1dkLow" }
        ],
        "aliases" : ["enna"]
      },
      {
        "name" : "Amano Pikamee",
        "groups": [["VOMS"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCajhBT4nMrg3DLS-bLL2RCg" }
        ],
        "aliases" : ["pikamee"]
      },
      {
        "name" : "Hikasa Tomoshika",
        "groups": [["VOMS"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC3vzVK_N_SUVKqbX69L_X4g" }
        ],
        "aliases" : ["tomoshika"]
      },
      {
        "name" : "Haneuzu Miuneru",
        "groups": [["VOMS"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCE5VgVGRPfNCjXPeTe1QJHA" }
        ],
        "aliases" : ["miuneru"]
      },
      {
        "name" : "Rinkou Ashelia",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCg7sW-h1PUowdiR5K4HlBew" }
        ],
        "aliases" : ["ashelia", "lia"]
      },
      {
        "name" : "Utatane Nasa",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCB7sSUNwh_dXE7ZL3DsGDpw" }
        ],
        "aliases" : ["nasa"]
      },
      {
        "name" : "Pipkin Pippa",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCJ46YTYBQVXsfsp8-HryoUA" }
        ],
        "aliases" : ["pipkin", "pippa"]
      },
      {
        "name" : "Tenma Maemi",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC3K7pmiHsNSx1y0tdx2bbCw" }
        ],
        "aliases" : ["tenma"]
      },
      {
        "name" : "Hakushika Iori",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCN5bD1YYapThOeadG7YkBOA" }
        ],
        "aliases" : ["iori"]
      },
      {
        "name" : "Fujikura Uruka",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCjXJYPsKxoJyc-1RPB6dSyw" }
        ],
        "aliases" : ["uruka"]
      },
      {
        "name" : "Shisui Michiru",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC1cExET9xoWSO9iSnRsW_1Q" }
        ],
        "aliases" : ["michiru"]
      },
      {
        "name" : "Remilia Nephys",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC-hMwvRuMsQrfgu0DPKLV2A" }
        ],
        "aliases" : ["remilia"]
      },
      {
        "name" : "Amanogawa Shiina",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCnJNNk45O1QYS2oMRYFKSyw" }
        ],
        "aliases" : ["shiina"]
      },
      {
        "name" : "Komachi Panko",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCVo_KgPNsDKxHwzib7uarCw" }
        ],
        "aliases" : ["panko"]
      },
      {
        "name" : "Erina Makina",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCupmjRr7kPgzXKh-cPxxGbg" }
        ],
        "aliases" : ["erina"]
      },
      {
        "name" : "Himemiya Rie",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCJ4O6PWA47f6XbCgrLQNqEQ" }
        ],
        "aliases" : ["rie"]
      },
      {
        "name" : "Chisaka Airi",
        "groups": [["PhaseConnect"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC5qlAhrec6-0J-K3zmhNPPQ" }
        ],
        "aliases" : ["airi"]
      },
      {
        "name" : "RoaFen",
        "groups": [["AkioAIR"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC4zOnqo9ZasN1vIHscCvzMg" }
        ],
        "aliases" : ["fen"]
      },
      {
        "name" : "Athena Nightingale",
        "groups": [["AkioAIR"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCzHjYL0ZSVs4tP-JutQLFrA" }
        ],
        "aliases" : ["athena"]
      },
      {
        "name" : "Kion Dojima",
        "groups": [["AkioAIR"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCycPDRVWCQakmKRKh6Z3Dqw" }
        ],
        "aliases" : ["kion"]
      },
      {
        "name" : "Nonoah",
        "groups": [["AkioAIR"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCbi3MM5-QP4MY1YkWfv4UJA" }
        ],
        "aliases" : ["nonoah"]
      },
      {
        "name" : "MEW Horizon",
        "groups": [["AkioAIR"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC1V0A85U1AGi-zQCC8oE55A" }
        ],
        "aliases" : ["mew"]
      },
      {
        "name" : "Nyanners",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "nyanners" }
        ],
        "aliases" : ["nyanners"]
      },
      {
        "name" : "Projekt Melody",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "projektmelody" }
        ],
        "aliases" : ["melody"]
      },
      {
        "name" : "Froot",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "apricot" }
        ],
        "aliases" : ["apricot"]
      },
      {
        "name" : "Zentreya",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "zentreya" }
        ],
        "aliases" : ["zentreya"]
      },
      {
        "name" : "Silvervale",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "silvervale" }
        ],
        "aliases" : ["silvervale"]
      },
      {
        "name" : "Ironmouse",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "ironmouse" }
        ],
        "aliases" : ["ironmouse"]
      },
      {
        "name" : "Hime Hajime",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "hajime" }
        ],
        "aliases" : ["hajime"]
      },
      {
        "name" : "Veibae",
        "groups": [["VShojo"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "veibae" }
        ],
        "aliases" : ["veibae"]
      },
      {
        "name" : "Hotaru Iora",
        "groups": [["VReverie"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC0g_U1QjfhMR-kx8XLmWTCA" }
        ],
        "aliases" : ["iora"]
      },
      {
        "name" : "Nova Aokami",
        "groups": [["VReverie"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCA4bOB1Jnw5-lbuoSCfxc-w" }
        ],
        "aliases" : ["nova"]
      },
      {
        "name" : "Lilrya Prisvielle",
        "groups": [["VReverie"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCt7vm-7hlwPcYsRacX7QJYw" }
        ],
        "aliases" : ["lilrya"]
      },
      {
        "name" : "Ophelia Midnight",
        "groups": [["VReverie"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UCZyNPQCjju3KIv9X84diljw" }
        ],
        "aliases" : ["ophelia"]
      },
      {
        "name" : "kson ONAIR",
        "groups": [["Indie"]],
        "streams" : [
          { "type" : "yt-channel", "value" : "UC9ruVYPv7yJmV0Rh0NKA-Lw" }
        ],
        "aliases" : ["kson"]
      },
      {
        "name" : "Snuffy",
        "groups": [["Indie"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "snuffy" }
        ],
        "aliases" : ["snuffy"]
      },
      {
        "name" : "Artemis of the Blue",
        "groups": [["Indie"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "artemisoftheblue" }
        ],
        "aliases" : ["artemis"]
      },
      {
        "name" : "girl_dm_",
        "groups": [["Indie"]],
        "streams" : [
          { "type" : "ttv-channel", "value" : "girl_dm_" }
        ],
        "aliases" : ["girl_dm_", "girldm"]
      }
    ]
  </script>
</body>
</html>
